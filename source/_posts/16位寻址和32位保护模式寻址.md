---
title: 16位寻址和32位保护模式寻址
date: 2016-12-05
tag: OS
---

&nbsp;&nbsp;&nbsp;&nbsp;16位下的寻址方式为CS:IP（段：偏移量）寻址。因为16位模式下，CPU中的算数逻辑单元（ALU）即数据总线只有16位，也就是说可以直接加以运算的指针长度是16位，但实模式下8086处理器有20位总线，也就是说8086处理器期望做到寻址1MB。因此，Intel设计者用的是分段的方法。Intel在8086 CPU中设置了四个16位段寄存器：CS、DS、SS和ES，分别用于可执行代码段、数据段、堆栈段和其他段，每个寄存器对应地址总线的高16位。每条访问指令（IP寄存器）中的内部地址也是16位的，但是在送上地址总线之前，CPU内部自动地将它与某个段寄存器中的内容左移4位之后再相加（段寄存器对应高16位），然后将形成的20位地址传递给总线。在16位实模式下，程序员指定的地址即是物理地址，也就是说低1MB物理内存地址对程序员是完全可见的。**实模式下段的大小固定为64k。** 

>  &nbsp;&nbsp;&nbsp;&nbsp;通过上述分段技术，可以表示的最大内存为：0xFFFF:FFFF=0x10FFEF（超出1MB的内存称为高端内存区HMA）。当程序员给出超过1MB（0x10000—0x10FFEF）的内存地址时，要实际访问地址就需要有第21根总线（A20）参与寻址，因此出现了两种不同的处理方式。当第21根总线打开时（enable），系统将实际访问这块内存。当第21根总线关闭（disable）时，系统计算实际地址时是按照对1M求模的方式进行的。这种技术被称为wrap-around。
>  &nbsp;&nbsp;&nbsp;&nbsp;对于80286或以上的CPU通过A20GATE来控制A20地址线。为了向下兼容（即在实模式中要求系统所表现的行为应该和8086/8088所表现的完全一样），绝大多数IBM PC兼容机（兼容IBM的PC机，一般用于指80486及之前的PC机）默认的A20Gate是被禁止的（只有第21根总线是特殊处理的，其他总线是开启的）在80286以及更高系列的PC中，A20Gate被打开。
>  &nbsp;&nbsp;&nbsp;&nbsp;在保护模式下，如果A20Gate被禁止，则其第20-bit在CPU做地址访问的时候是无效的，永远只能被作为0，则可以访问的内存只能是奇数1M段，即1M,3M,5M…，也就是00000-FFFFF,200000-2FFFFF,400000-4FFFFF…。如果A20 Gate被打开，则可以访问的内存则是连续的。所以在进入保护模式之前要检查A20Gate是否打开。

&nbsp;&nbsp;&nbsp;&nbsp;由于在实模式中，每一个指针都是指向“实在”的物理地址，而如果用户指针一不小心指向了系统或其他程序区域并改变了值，那么就GG了。所以产生了保护模式。在保护模式中，物理内存地址不能直接被程序访问，程序内部的地址（虚拟地址）要由操作系统转化为物理地址去访问，程序对此一无所知。 

&nbsp;&nbsp;&nbsp;&nbsp; 保护模式出现的目的即在于**保护进程地址空间。** 

&nbsp;&nbsp;&nbsp;&nbsp;在32位保护模式下，全部32位地址总线有效，可寻址4GB物理内存空间。保护模式并没有抛弃实模式下Seg：Offset这样的寻址方式，只是对Seg的解释发生了变化。实模式下段值可以看作是地址的一部分，而保护模式下，段寄存器还是原来的16位，但它仅仅只是一个索引，它指向一个数据结构的一个表项，这个数据结构就是大名鼎鼎的GDT，GDT定义了段的起始地址、界限和属性。 

&nbsp;&nbsp;&nbsp;&nbsp; **全局描述符表GDT（Global Descriptor Table）**在整个系统中，全局描述符表GDT只有一张(一个处理器对应一个GDT)，GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者门提供了一个**寄存器GDTR用来存放GDT的入口地址**，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDTR中存放的是GDT在内存中的基地址和其表长界限。 

&nbsp;&nbsp;&nbsp;&nbsp;基地址指定GDT表中字节0在线性地址空间中的地址，表长度指明GDT表的字节长度值。指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。在保护模式初始化过程中必须给GDTR加载一个新值。 

![GDTR](/images/GDTR.jpg) 

&nbsp;&nbsp;&nbsp;&nbsp;段选择子（Selector）由GDTR访问全局描述符表是通过“段选择子”（实模式下的段寄存器）来完成的。段选择子是一个16位的寄存器（同实模式下的段寄存器相同） 

![Selector](/images/Selector.png) 

&nbsp;&nbsp;&nbsp;&nbsp;段选择子包括三部分：**描述符索引（index）、TI、请求特权级（RPL）**。它的index（描述符索引）部分表示所需要的段的描述符在描述符表的位置，由这个位置再根据在GDTR中存储的描述符表基址就可以找到相应的描述符。然后用描述符表中的段基址加上逻辑地址（SEL:OFFSET）的OFFSET就可以转换成线性地址，段选择子中的TI值只有一位0或1，0代表选择子是在GDT选择，1代表选择子是在LDT选择。请求特权级（RPL）则代表选择子的特权级，共有4个特权级（0级、1级、2级、3级）。 

&nbsp;&nbsp;&nbsp;&nbsp;关于特权级的说明：任务中的每一个段都有一个特定的级别。每当一个程序试图访问某一个段时，就将该程序所拥有的特权级与要访问的特权级进行比较，以决定能否访问该段。系统约定，CPU只能访问同一特权级或级别较低特权级的段。 

&nbsp;&nbsp;&nbsp;&nbsp;例如给出逻辑地址：**21h:12345678h**  转换为线性地址 

&nbsp;&nbsp;&nbsp;&nbsp;a. 选择子SEL=21h=0000000000100 0 01b 它代表的意思是：选择子的index=4即100b选择GDT中的第4个描述符；TI=0代表选择子是在GDT选择；左后的01代表特权级RPL=1 

&nbsp;&nbsp;&nbsp;&nbsp; b. OFFSET=12345678h若此时GDT第四个描述符中描述的段基址（Base）为11111111h，则线性地址=11111111h+12345678h=23456789h 

&nbsp;&nbsp;&nbsp;&nbsp;**局部描述符表LDT（Local Descriptor Table）**局部描述符表可以有若干张，每个任务可以有一张。我们可以这样理解GDT和LDT：GDT为一级描述符表，LDT为二级描述符表。如图 

![LDT](/images/LDT.jpg) 

&nbsp;&nbsp;&nbsp;&nbsp;LDT和GDT从本质上说是相同的，只是LDT嵌套在GDT之中（LDT描述符在GDT中）。**LDTR记录局部描述符表的起始位置**，与GDTR不同，**LDTR的内容是一个段选择子**。由于LDT本身同样是一段内存，也是一个段，所以它也有个描述符描述它，这个描述符就存储在GDT中，对应这个表述符也会有一个选择子，LDTR装载的就是这样一个选择子。LDTR可以在程序中随时改变，通过使用lldt指令。如上图，如果装载的是Selector 2则LDTR指向的是表LDT2。举个例子：如果我们想在表LDT2中选择第三个描述符所描述的段的地址12345678h。 

1.首先需要装载LDTR使它指向LDT2，使用指令lldt将Select2装载到LDTR
2.通过逻辑地址（SEL:OFFSET）访问时SEL的index=3代表选择第三个描述符；TI=1代表选择子是在LDT选择，此时LDTR指向的是LDT2,所以是在LDT2中选择，此时的SEL值为1Ch(二进制为11 1 00b)。OFFSET=12345678h。逻辑地址为1C:12345678h
3.由SEL选择出描述符，由描述符中的基址（Base）加上OFFSET可得到线性地址，例如基址是11111111h，则线性地址=11111111h+12345678h=23456789h
4.此时若再想访问LDT1中的第三个描述符，只要使用lldt指令将选择子Selector 1装入再执行2、3两步就可以了（因为此时LDTR又指向了LDT1） 

&nbsp;&nbsp;&nbsp;&nbsp;由于每个进程都有自己的一套程序段、数据段、堆栈段，有了局部描述符表则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变LDTR就可以实现对不同进程的段进行访问。 

&nbsp;&nbsp;&nbsp;&nbsp;当进行任务切换时，处理器会把新任务LDT的段选择符和段描述符自动地加载进LDTR中。在机器加电或处理器复位后，段选择符和基地址被默认地设置为0，而段长度被设置成0xFFFF。 


#### 实例####

&nbsp;&nbsp;&nbsp;&nbsp; 1：访问GDT 

![GDT-DEMO](/images/GDT-DEMO.jpg) 

&nbsp;&nbsp;&nbsp;&nbsp;当TI=0时表示段描述符在GDT中，如上图所示： 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①先从GDTR寄存器中获得GDT基址 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②然后再GDT中以段选择器高13位位置索引值得到段描述符。 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段的起始地址（基址），再以基址加上偏移地址yyyyyyyy才得到最后的线性地址。 

&nbsp;&nbsp;&nbsp;&nbsp; 2：访问LDT 

![LDT-DEMO](/images/LDT-DEMO.jpg) 

&nbsp;&nbsp;&nbsp;&nbsp;当TI=1时表示段描述符在LDT中，如上图所示： 

&nbsp;&nbsp;&nbsp;&nbsp;①还是先从GDTR寄存器中获得GDT基址。 

&nbsp;&nbsp;&nbsp;&nbsp;②从LDTR寄存器中获取LDT所在段的位置索引(LDTR高13位)。 

&nbsp;&nbsp;&nbsp;&nbsp;③以这个位置索引在GDT中得到LDT段描述符从而得到LDT段基址。 

&nbsp;&nbsp;&nbsp;&nbsp;④用段选择器高13位位置索引值从LDT段中得到段描述符。 

&nbsp;&nbsp;&nbsp;&nbsp;⑤段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段的起始地址（基址），再以基址加上偏移地址yyyyyyyy才得到最后的线性地址。 


#### 扩展####

除了GDTR、LDTR外还有**IDTR**和**TR** 

（1）**中断描述符表寄存器IDTR** 

&nbsp;&nbsp;&nbsp;&nbsp;与GDTR的作用类似，IDTR寄存器用于存放中断描述符表IDT的32位线性基地址和16位表长度值。指令LIDT和SIDT分别用于加载和保存IDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。

（2）**任务寄存器TR** 

&nbsp;&nbsp;&nbsp;&nbsp;TR用于寻址一个特殊的任务状态段（Task State Segment，TSS）。TSS中包含着当前执行任务的重要信息。 

&nbsp;&nbsp;&nbsp;&nbsp;TR寄存器用于存放当前任务TSS段的16位段选择符、32位基地址、16位段长度和描述符属性值。它引用GDT表中的一个TSS类型的描述符。指令LTR和STR分别用于加载和保存TR寄存器的段选择符部分。当使用LTR指令把选择符加载进任务寄存器时，TSS描述符中的段基地址、段限长度以及描述符属性会被自动加载到任务寄存器中。当执行任务切换时，处理器会把新任务的TSS的段选择符和段描述符自动加载进任务寄存器TR中。 










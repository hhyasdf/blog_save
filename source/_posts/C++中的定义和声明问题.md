---
title: C++中的定义和声明问题
date: 2018-01-19 19:45:32
categories: C++
tags: 
	- C++
---

C++中的定义和声明一直是比较纠结的问题（可能是在下半吊子编译原理太菜。。。）在此总结一下各种需要注意的声明和定义问题。（gcc环境）

首先理基本概念，#include 会在其所在源文件的对应位置将头文件**原封不动全部展开**（预处理阶段），编译器只处理每个预处理后的源文件（.cpp）并生成每一个源文件相对应的汇编文件（.s），然后汇编器将每个汇编文件汇编成目标文件（.o），链接器再将目标文件链接成一个可执行文件。

> 编译的过程以源文件为单元进行，**每个源文件中的编译信息都是独立的**，对其他源文件不可见，编译时只需要声明来确定名字的信息。编译阶段只会检查语法错误和生成每个文件中定义的实体。

目标文件中每个名字都对应一个符号，可以将其分为**强符号**和**弱符号**（包括未定义符号）。强符号一定对应一个实体，并且不能存在两个相同的强符号。当存在相同名字的强符号和弱符号时，链接器会忽略弱符号，只使用强符号。可以存在多个相同名字的弱符号，当不存在与弱符号对应的实体时，链接会报错。当存在多个与弱符号对应的实体时，链接器会选择任意一个实体绑定所有相同名字的弱符号（依赖于实现，可执行文件中不会有其他对应弱符号的实体）。

<!---- more ----->



> PS：这里的实体的是目标文件中的一块区域，比如一个变量名字对应的存储空间可以在bss段、data段、栈段中，一个函数名字对应的存储空间一般在代码段中描述了函数的指令流。类会被拆解成函数和变量（本质上就是逻辑上有关系的函数和变量）。 

#### 声明 ####

C++中声明的目的是让编译器知道某个名字的存在以及该其表示一个什么样的实体，如一个类、一个函数或一个变量等。编译器不会为一个声明在目标文件中建立存储空间，**而是为一个文件中所使用的只声明但未定义的每个名字都生成一个未定义符号（U）**，表示实体实际上存储在其他地方，需要链接器去其他地方链接一个实体过来。同一个文件中可一个多次声明。没有定义可以过编译但是不能过链接。（gcc的c mode 中一个没有初始化的变量不会默认初始化，此时是一个声明，很迷...）

> PS：如果一个声明的名字没有被使用则不会生成一个弱符号

#### 定义 ####

编译器为一个定义在目标文件中建立了存储空间，并且生成了一个强符号，一个定义必须出现并且只能出现一次（链接时强符号不能同时存在多个），所以其他用到该名字的文件必须对其进行声明，但绝对不能对其重复定义（编译器会对同一个文件中的重复定义报错，链接器会对多个文件中的重复定义报错）。所以头文件用不能有任何定义（除了模板）。

> 引用是一个强符号，指向一个实体，但符号名字与实体原来的名字不同

************

C++中变量（包括对象）的声明和定义（初始化）如果不加extern就是同时产生的。而对于函数来说声明和定义是分开的，定义必须有函数体。所以变量的声明一定要加extern，不加就是定义（默认或直接初始化）。函数的声明可以省略extern。而类中与类本身在链接文件中的有关的部分只有静态数据成员和函数成员。类中的static数据成员如果没有初始化就是声明，有初始化就是定义：

```c++
/***** test.h: ******/

class A{
public:
  static int a; //声明
  static int a = 0; // 定义，错误，除了constexpr的静态成员不能在头文件中定义
};
int A::a = 0 // 错误，多个文件的重复定义
  
/***** test.c: ******/

int A::a = 0; // 只能在源文件中定义
```

而类中的函数成员与一般的函数一样，只有有函数体才是定义，并且在类内的函数成员定义默认为内联函数直接展开（在编译时），而类外定义是普通函数定义，所以不能有多个定义（头文件中不能类外定义函数）。如果类中的函数只有定义没有声明，或者存在对应函数定义的源文件的目标文件没有被链接进来，可以过编译但是不能过链接。

#### 模板 ####

首先我们要明确，模板只在编译阶段有作用，编译完之后会生成每个模板类的实体。然后链接的是模板类，可以当做一个普通的类看待。一般情况下（隐式实例化），**类模板的成员只有在被使用时才会被实例化，如果此时源文件内（#include展开后）只有模板声明没有对应成员定义，那么编译器会和之前一样生成一个未定义符号**；（此处只针对与类本身的实体相关的静态数据成员和函数成员）如果存在定义，则编译器会在每个使用了类模板的源文件对应的目标文件中实例化出对应成员的实体。重点是：（gcc）**实例化出来的实体对应的都是弱符号**（nm中的W）所以这种情况下多个源文件中存在多个定义（在头文件中的类模板外定义不会报错）。

可以用显式实例化来提高模板效率，使每个模板只需要实例化一次：

```c++
template class Bob<int>; // 实例化定义，会实例化该模板的所有成员

extern template class Bob<int>; // 实例化声明，表示其他地方有该模板成员的定义，对应模板的所有成员
  								// 的名字都是未定义符号（U）
```

类模板的类内定义为隐式内联，用显示实例化无法提高效率。

> 经过实验，gcc中显式实例化定义出来的类也是弱符号，所以可以实例化定义多次，跟c++ primer上不一样.....

由于模板（的概念）只在编译时存在，模板的定义在编译时只在对应存在该模板定义的源文件中可见，所以在源文件中的类（模板）外定义对于其他文件是不可见的，如果存在定义的源文件中没有实例化出来一个对应成员的实体，而另一个源文件中的main函数中使用了该成员，仍可以过编译，此时使用该成员名字的源文件中没有定义，而只有声明（头文件中有模板的声明信息），编译器会生成对应名字的一个未定义符号，直到在链接时无法发现一个对应的实体才会报错。这种情况下可以在有对应类外定义的源文件中显示实例化整个类实体或隐式实例化定义对应的成员，然后链接起来解决该问题：

```c++
/***** test.h: ******/

template <typename T>
class Tem{
public:
	int func2(int);
};
  
/***** test.c: ******/

#include "test.h"

template <typename T>
int Tem<T>::func2(int a){
	return a;
}
// 可以在此处加上 Tem<int> e;int m = e.func2(1); 或 template class Tem<int>; 解决

/***** a.cpp: ******/
、
#include "test.h"

int main() {
    Tem<int> m;   
    m.func2(1);   // gcc a.cpp test.cpp 可以过编译但是不能过链接，func2是一个未定义符号
    return 0;
}

```

> Tips：linux下可以使用 nm 和 c++filt 查看二进制文件中的符号信息，对应的命令为 nm xxx.out | c++filt 或 nm xxx.o | c++filt ，其中 c++filt 使c++符号信息可读。